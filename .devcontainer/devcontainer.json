<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Higgs Field Anchors Simulation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
        }

```
    #container {
        width: 100%;
        height: 600px;
        border: 2px solid #4a90e2;
        border-radius: 10px;
        overflow: hidden;
        position: relative;
    }
    
    #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px;
        border-radius: 8px;
        z-index: 100;
        font-size: 14px;
        max-width: 300px;
    }
    
    .legend {
        margin-top: 10px;
        display: flex;
        flex-direction: column;
        gap: 5px;
    }
    
    .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    
    .color-box {
        width: 15px;
        height: 15px;
        border-radius: 3px;
    }
    
    .cube-box {
        width: 15px;
        height: 15px;
        border-radius: 0px;
        border: 2px solid #44ff44;
    }
    
    .controls {
        margin-top: 20px;
        text-align: center;
    }
    
    button {
        background: #4a90e2;
        color: white;
        border: none;
        padding: 10px 20px;
        margin: 0 10px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
    }
    
    button:hover {
        background: #357abd;
    }
    
    h1 {
        text-align: center;
        margin-bottom: 20px;
    }
</style>
```

</head>
<body>
    <h1>3D Spatial Distribution of Higgs Field Anchors</h1>

```
<div id="container">
    <div id="info">
        <strong>Digital Root Anchor System</strong>
        <div class="legend">
            <div class="legend-item">
                <div class="color-box" style="background-color: #ff4444;"></div>
                <span>Digital Root 9 (Collapse Anchor)</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background-color: #4444ff;"></div>
                <span>Digital Root 6 (Balance Anchor)</span>
            </div>
            <div class="legend-item">
                <div class="cube-box" style="background-color: #44ff44;"></div>
                <span>Digital Root 3 (Entry Anchor - Cubes)</span>
            </div>
            <div class="legend-item">
                <div style="width: 15px; height: 2px; background-color: #6666ff; opacity: 0.6;"></div>
                <span>Route 6 Connections</span>
            </div>
        </div>
    </div>
</div>

<div class="controls">
    <button onclick="toggleRotation()">Toggle Rotation</button>
    <button onclick="resetView()">Reset View</button>
    <button onclick="toggleConnections()">Toggle Route 6 Connections</button>
    <button onclick="toggleWireframe()">Toggle Wireframe</button>
</div>

<script>
    let scene, camera, renderer, particles = [];
    let route6Anchors = [];
    let connectionLines = [];
    let isRotating = true;
    let wireframe = false;
    let showConnections = true;
    
    function init() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000011);
        
        // Create camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / 600, 0.1, 1000);
        camera.position.set(80, 80, 80);
        camera.lookAt(25, 25, 25);
        
        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(document.getElementById('container').offsetWidth, 600);
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Generate data points
        generateParticles();
        
        // Add lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        scene.add(directionalLight);
        
        // Add coordinate axes
        addAxes();
        
        // Start animation
        animate();
    }
    
    function generateParticles() {
        const numPoints = 500;
        
        // Digital Root 9 - Collapse Anchors (centered near origin)
        const num9 = Math.floor(numPoints * 0.3);
        for (let i = 0; i < num9; i++) {
            const geometry = new THREE.SphereGeometry(0.8, 8, 8);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0xff4444,
                transparent: true,
                opacity: 0.8
            });
            const sphere = new THREE.Mesh(geometry, material);
            
            sphere.position.x = gaussianRandom(25, 5);
            sphere.position.y = gaussianRandom(25, 5);
            sphere.position.z = gaussianRandom(25, 5);
            
            scene.add(sphere);
            particles.push(sphere);
        }
        
        // Digital Root 6 - Balance Anchors (mid regions)
        const num6 = Math.floor(numPoints * 0.35);
        for (let i = 0; i < num6; i++) {
            const geometry = new THREE.SphereGeometry(0.6, 8, 8);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x4444ff,
                transparent: true,
                opacity: 0.6
            });
            const sphere = new THREE.Mesh(geometry, material);
            
            sphere.position.x = gaussianRandom(25, 12);
            sphere.position.y = gaussianRandom(25, 12);
            sphere.position.z = gaussianRandom(25, 12);
            
            scene.add(sphere);
            particles.push(sphere);
            route6Anchors.push(sphere);
        }
        
        // Digital Root 3 - Entry Anchors (near edges) - Using Cubes
        const num3 = Math.floor(numPoints * 0.35);
        for (let i = 0; i < num3; i++) {
            const geometry = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            const material = new THREE.MeshLambertMaterial({ 
                color: 0x44ff44,
                transparent: true,
                opacity: 0.6
            });
            const cube = new THREE.Mesh(geometry, material);
            
            const edges = [0, 50];
            cube.position.x = edges[Math.floor(Math.random() * 2)] + gaussianRandom(0, 1);
            cube.position.y = edges[Math.floor(Math.random() * 2)] + gaussianRandom(0, 1);
            cube.position.z = edges[Math.floor(Math.random() * 2)] + gaussianRandom(0, 1);
            
            scene.add(cube);
            particles.push(cube);
        }
        
        // Create connections between all route 6 anchors
        createRoute6Connections();
    }
    
    function createRoute6Connections() {
        // Create lines connecting all route 6 anchors to each other
        for (let i = 0; i < route6Anchors.length; i++) {
            for (let j = i + 1; j < route6Anchors.length; j++) {
                const points = [];
                points.push(new THREE.Vector3(
                    route6Anchors[i].position.x,
                    route6Anchors[i].position.y,
                    route6Anchors[i].position.z
                ));
                points.push(new THREE.Vector3(
                    route6Anchors[j].position.x,
                    route6Anchors[j].position.y,
                    route6Anchors[j].position.z
                ));
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x6666ff,
                    transparent: true,
                    opacity: 0.2
                });
                const line = new THREE.Line(geometry, material);
                
                scene.add(line);
                connectionLines.push(line);
            }
        }
    }
    
    function addAxes() {
        const axesHelper = new THREE.AxesHelper(30);
        scene.add(axesHelper);
        
        // Add wireframe cube to show bounds
        const geometry = new THREE.BoxGeometry(50, 50, 50);
        const edges = new THREE.EdgesGeometry(geometry);
        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
            color: 0x666666,
            transparent: true,
            opacity: 0.3
        }));
        line.position.set(25, 25, 25);
        scene.add(line);
    }
    
    function gaussianRandom(mean = 0, stdev = 1) {
        const u = 1 - Math.random();
        const v = Math.random();
        const z = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        return z * stdev + mean;
    }
    
    function animate() {
        requestAnimationFrame(animate);
        
        if (isRotating) {
            camera.position.x = Math.cos(Date.now() * 0.0005) * 100;
            camera.position.z = Math.sin(Date.now() * 0.0005) * 100;
            camera.lookAt(25, 25, 25);
        }
        
        // Add subtle particle movement
        particles.forEach((particle, index) => {
            particle.rotation.x += 0.01;
            particle.rotation.y += 0.01;
            
            // Subtle floating motion
            particle.position.y += Math.sin(Date.now() * 0.001 + index) * 0.02;
        });
        
        renderer.render(scene, camera);
    }
    
    function toggleRotation() {
        isRotating = !isRotating;
    }
    
    function resetView() {
        camera.position.set(80, 80, 80);
        camera.lookAt(25, 25, 25);
    }
    
    function toggleConnections() {
        showConnections = !showConnections;
        connectionLines.forEach(line => {
            line.visible = showConnections;
        });
    }
    
    function toggleWireframe() {
        wireframe = !wireframe;
        particles.forEach(particle => {
            particle.material.wireframe = wireframe;
        });
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
        const container = document.getElementById('container');
        camera.aspect = container.offsetWidth / 600;
        camera.updateProjectionMatrix();
        renderer.setSize(container.offsetWidth, 600);
    });
    
    // Initialize the simulation
    init();
</script>
```

</body>
</html>{
  "image": "mcr.microsoft.com/devcontainers/universal:2",
  "features": {}
}
